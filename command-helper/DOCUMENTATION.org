#+TITLE: Documentation
* Intro
  #+BEGIN_QUOTE
  Centralizamos los comentarios sobre las implementaciones en los Makefiles,
  para separar la explicación de la implementación en si
  #+END_QUOTE
* Comparación de Timestamp entre Target y sus dependencias
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Problemas con éste target:
    #
    # 1. al utilizar el símbolo ; dentro del foreach se ejecutará en cada iteración
    # y al igual que en la terminal de linux, hará que cada comando se ejecute de forma independiente
    #
    # 2. lo anterior es problema suponiendo que queremos transformar la información generada
    # (Ej. agregandole una cabecera)
    #
    imprimir-comando-descripcion:
    $(foreach comando, $(DOC_COMANDOS_LINUX), cat $(comando) | sed -n '1p';)
  #+END_SRC

  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Problemas con estos targets:
    #
    # 1. estamos creando un archivo comandos-linux.txt cada vez que ejecutamos imprimir-comandos,
    # es decir no comprobamos si se actualizaron ó no los archivos contenidos en $(DOC_COMANDOS_LINUX)
    #
    # 2. no estamos aprovechando la comparación del timestamp entre el target y las dependencias para crear archivos de GNU Make,
    # la manera más común sería una regla como la siguiente.. archivo-transformado.txt: archivo1.txt archivo2.txt archivo3.txt
    #
    imprimir-comandos: comandos-linux.txt

    comandos-linux.txt:
      $(foreach comando, $(DOC_COMANDOS_LINUX), cat $(comando) | sed -n '1p';)
  #+END_SRC
* Función Basename
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Nota: $(patsubst pattern, replacement, text)

    # Problemas:
    # 1. NO era necesario utilizar la función patsubst, sólo necesitabamos usar la función basename de GNU Make
    # 2. Si bien le ponemos "WRONG", éste método funciona pero se pierde expresividad y es más dificil de mantener
    COMANDOS_LINUX_WRONG = $(notdir $(patsubst %.sh,%,$(DOC_COMANDOS_LINUX)))

    COMANDOS_LINUX = $(basename $(notdir $(DOC_COMANDOS_LINUX)))
  #+END_SRC
* Función filter-out
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)
    DOC_SHORTCUTS_LINUX = $(wildcard doc/*.org)

    # Nota: $(filter-out pattern, text)
    #
    # 1. Filtramos de (A) los elementos (a) que no estén incluidos en otra lista (B)
    #
    COMANDOS_LINUX_WITHOUT_SHORTCUTS = $(filter-out $(SHORTCUTS_LINUX),$(COMANDOS_LINUX))
  #+END_SRC
* Comando bat
** Problema al ejecutar
  #+BEGIN_QUOTE
  *Posible Problema:*
  - al ejecutar el binario el emulador de terminal diga ~Command 'bat' not found~

  *Solución:*
  - crear un softlink de ~/usr/bin/batcat~ en  ~~/.local/bin/bat~
  #+END_QUOTE

#+BEGIN_SRC shell
  # suponiendo que no existe el directorio
  mkdir -p ~/.local/bin

  # creamos el softlink /usr/bin/batcat en ~/.local/bin/bat
  ln -s /usr/bin/batcat ~/.local/bin/bat
#+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://www.makeuseof.com/bat-an-alternative-to-cat-command/][bat an alternative to cat omcmand (makeuseof.com)]]
*** Referencias Issues
    1. [[https://github.com/sharkdp/bat/issues/1420#issuecomment-737058971][Bat doesn't work when installed from apt on ubuntu (github.com/sharkdp/bat)]]
* Macro Expansiva Vs Macro Simple - Evaluación y Expansión de Macro con comando shell
** Problemas
  #+BEGIN_QUOTE
  Según la que eligamos dará *problemas ó no cuando les asignamos un comando de shell*..

  Si es una *MACRO RECURSIVA*, entonces utilizamos el símbolo de asignación ~=~
  Por ejemplo ~archivo-especifico = $(shell ls *.md | grep '^READ')~
  - PROBLEMA 1: GNU Make lo evaluará y expandirá cada vez que se referencie en el Makefile
  - PROBLEMA 2: ejecuta el comando a cada rato, en lugares dónde aún no queríamos que se ejecutara (Ej. en un ifeq)

  Si es una *MACRO SIMPLE*, entonces utilizamos el símbolo de asignación ~:=~
  - Por ejemplo ~archivo-especifico := $(shell ls *.org | grep 'TODO\.org$')~
  - PROBLEMA 1: GNU Make lo evaluará varias veces pero se expandirá una única vez (la primera vez que se referenció)
  - PROBLEMA 2: ejecutará apenas ejecutamos el Makefile (peor que antes)
  #+END_QUOTE

  #+BEGIN_SRC makefile
    # a diferencia de las alternativas de abajo, ésta si funciona y evitamos los problemas de expansión no deseada de GNU Make
    POPUP_EDIT = sh ./scripts/edit-popup.sh

    # Notas:
    # - en todas las siguientes asignaciones causarán problemas cuando GNU Make las evalué y expanda
    # - de igual forma las comento por el tema de que cada linea en una regla de Makefile se ejecuta en una shell diferente

    # 1. alternativa a la función shell sería usando el símbolo !=
    # 2. en éste ejemplo considero que queda mejor usar shell para no confundir y no olvidar que el comando read es propio de linux
    POPUP_EDIT != read -p "Si desea editar comandos escriba sin paréntesis (c) y para shortcuts (s): " popup_edit; echo $$popup_edit

    #
    # 1. nuestro comando shell imprimirá un string que se asignará a la macro POPUP_EDIT
    # 2. los comandos de linux se ejecutarán en la misma shell, por tanto se perderá el valor si intentamos imprimir $$popup_edit en otra macro ó target
     POPUP_EDIT ?= $(shell read -p "Desea editar comandos escriba (c) para shortcuts (s): " popup_edit; echo $$popup_edit)

    # 1. también sólo podriamos asignar los comandos a ejecutar como un string
    # 2. para no perder el valor de popup_edit podríamos utilizar el operador && para manternos en la misma shell así $(POPUP_EDIT) && echo $$popup_edit
    # pero... no podriamos utilizarlo en un ifeq de GNU Make
     POPUP_EDIT = read -p "Si desea editar comandos escriba sin paréntesis (c) y para shortcuts (s): " popup_edit; echo $$popup_edit
  #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://make.mad-scientist.net/deferred-simple-variable-expansion/][Deferred simple variable expansion (make-mad-scientist.net)]]
    2. [[https://seanbone.ch/makefile-hacks/][Makefile hacks (seanbone.ch)]]
*** Referencias Issues
    1. [[https://nono.ma/prompt-user-input-makefile][Prompt user input makefile (nono.ma)]]
    2. [[https://stackoverflow.com/questions/3743793/makefile-why-is-the-read-command-not-reading-the-user-input][makefile why is the read command not reading the user input (stackoverflow.com)]]
    3. [[https://unix.stackexchange.com/questions/31414/how-can-i-pass-a-command-line-argument-into-a-shell-script][How can I pass a command line argument into a shell script (unix.stackexchange.com)]]
    4. [[https://stackoverflow.com/questions/32153034/oneshell-not-working-properly-in-makefile][Oneshell not working properly in makefile (stackoverflow.com)]]
* Condicionales Simples de Bash
** Problemas
  #+BEGIN_QUOTE
  Podemos usar el comando ~test -f archivo~ para verificar si existe con los operadores lógicos ~&&~ y ~||~
  - la expresión seguida del operador lógico AND ~&&~ se evalúa si existe el archivo
  - la expresión seguida del operador lógico OR ~||~ se evalúa si NO existe el archivo

  ó podemos usar el condicional ~if [ -s archivo ]~ sin olvidar el uso de los ~;~
  - usar ~;~ al final de cada expresión delimitada dentro de la condición ~if~ ó del ~else~
  - finalizar el bloque ~if~ con un ~fi~
  #+END_QUOTE

  #+BEGIN_SRC makefile
    doc/archivo.txt: .tmp/archivo-4.txt .tmp/archivo-1.txt .tmp/archivo-9.txt
      @test -f $@ \
      && echo "existe el archivo..!" \
      || echo "no existe el archivo, ejecutar algún comando que procese los archivos dependencia y cree el archivo"

    doc/otro-archivo.txt: .tmp/archivo-1.txt .tmp/archivo-2.txt .tmp/archivo-3.txt
      @if [ -s $@  ]; then \
        echo "existe el archivo"; \
      else \
        echo "no existe el archivo, ejecutar algún comando que procese los archivos dependencia y cree el archivo"; \
      fi
  #+END_SRC
** Referencias
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/5553352/how-do-i-check-if-file-exists-in-makefile-so-i-can-delete-it][How do I check if file exists in makefile (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/8059556/how-to-write-multiple-conditions-in-makefile-am-with-else-if][How to write multiple conditions in makefile (stackoverflow.com)]]
* awk + sed - Expresiones Regulares
** Ejemplo Básico
  #+BEGIN_QUOTE
  Generamos un archivo ~comandos-linux.txt~ en base al contenido de sus dependencias (los .sh)
  - siempre que en una regla de Makefile haya una diferencia en el *timestamp* entre el TARGET y sus DEPENDENCIAS
  - con la diferencia de timestamp, GNU Make nos permitirá ejecutar la orden asociada a la creación del TARGET
  - creamos el archivo (target) cuando los archivos de los que depende (sus dependencias) tienen una fecha de modificación más reciente
 #+END_QUOTE

  #+BEGIN_SRC makefile
    # - truncamos el archivo, lo modificamos el tamaño del archivo a cero Bytes
    # - todos los datos que tenía se pierden
    archivo.txt:
      @truncate -s 0 $@

    # - iteramos sobre cada dependencia del target
    # - la macro especial $^ obtiene todas  las dependencias
    # - la función foreach es de la forma (foreach elemento-de-la-lista, lista-de-archivos, orden-a-ejecutar)
    # - para utilizar el elemento de la iteración del foreach dentro de la orden que ejecuta, debemos hacerlo como una macro $(elemento-de-la-lista)
    @$(foreach comando, $^, echo $(comando))

    # obtenemos una linea en particular del archivo (la descripción, en la primera linea)
    cat archivo.txt | sed -n '1p'

    # agregamos un string al principio de cada linea
    cat archivo.txt | nawk '{print "$(basename $(notdir $(comando))) " $$0}'

    # - reemplazamos los símbolos no deseados por ejemplo ~#~ por otro por ej. el pipe ~|~
    # - escapamos los símbolos usando el slash invertido
    cat archivo.txt | sed 's/\#/\|/g'

    # - agregamos el texto transformado en el target (el archivo comandos-linux.txt)
    # - el operador de redirección ~>>~ que agrega contenido (si usaramos ~>~ borraría el contenido anterior)
    # - la macro especial ~$@~ que obtiene el nombre del target
    archivo.txt:
      echo "texto transformado" >> $@
  #+END_SRC

  #+BEGIN_SRC makefile
    comandos-linux.txt: doc/ls.sh doc/mv.sh doc/tar.sh doc/curl.sh
      @$(TRUNCATE_CLEAR_CONTENT) $@
      @$(foreach comando, $^,\
      cat $(comando) | sed -n '1p' | nawk '{print "$(basename $(notdir $(comando))) " $$0}' | sed 's/\#/\|/g' \
      >> $@;\
    )
  #+END_SRC
** Ejemplo
  #+BEGIN_SRC makefile
    comandos-linux.txt: doc/ls.sh doc/mv.sh doc/tar.sh doc/curl.sh
      @$(TRUNCATE_CLEAR_CONTENT) $@
      @$(foreach comando, $^,\
        cat $(comando) | \
        sed -n '1,2p' | \
        nawk 'BEGIN{print "$(basename $(notdir $(comando)))|" } {print $$0}' | \
        sed -E 's/\#\# (CATEGORIA)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2\|/g' | \
        sed -E 's/\#\# (DESCRIPCION)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2;/g' | \
        tr --delete '\n' | tr ';' '\n' | \
        nawk -F '|' '{print $$1 " | " toupper($$2) " | " toupper(substr($$3,1,1)) substr($$3,2)}' \
        >> $@;\
      )
  #+END_SRC

  #+BEGIN_SRC makefile
    # extraemos sólo las lineas 1 y 2 del archivo
    cat archivo.txt | sed -n '1,2p'

    # - agregamos al principio de cada linea un texto, en éste caso la macro comando
    # - la función notdir obtiene el nombre del archivo (con la extensión, usaremos basename para removerla)
    # - la función basename obtiene el nombre del archivo sin la extensión
    # - usamos $$0 en vez de $0 para que GNU Make no la tome como una macro de Makefile si que la escape é interprete un caracter y sea un parámetro del comando awk
    cat archivo.txt | nawk 'BEGIN{print "$(basename $(notdir $(comando)))|" } {print $$0}'

    # - en las regex es típico usar paréntesis para los Grupos de Captura (Capture Group) es decir son "Construcciones de Agrupamiento de Expresiones Regulares"
    # - en awk obtenemos el contenido de los Grupos de Captura con \1 \2 .. \n siendo n el número del grupo de captura del que queremos el contenido
    cat archivo.txt | sed -E 's/\#\# (CATEGORIA)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2\|/g'

    # - al final de cada columna de awk le agregamos un símbolo ; como centinela para detectar el fin de linea
    cat archivo.txt | sed -E 's/\#\# (DESCRIPCION)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2;/g'

    # borramos los saltos de linea
    cat archivo.txt | tr --delete '\n'

    # reemplazamos los ; por saltos de linea (antes los habíamos agregado para diferenciar el fin de linea)
    cat archivo.txt | tr ';' '\n'

    # - indicamos que el separador de las columnas en el símbolo | (el pipe)
    # - transformamos el texto manipulando el orden de las columnas $1 $2 $3 detectadas por awk
    # (recordando que agregamos un $ al principio $$1 $$2 .. porque si nó GNU Make lo tomará como una macro, y queremos que lo tome como un caracter)
    cat archivo.txt | nawk -F '|' '{print $$1 " | " toupper($$2) " | " toupper(substr($$3,1,1)) substr($$3,2)}'
  #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://learn.microsoft.com/es-es/dotnet/standard/base-types/grouping-constructs-in-regular-expressions][Construcciones de agrupamiento en expresiones regulares (learn.mirosoft.com)]]
*** Referencias Extraoficiales
    1. [[http://w3.unpocodetodo.info/utiles/regex-en-javascript.php][Grupos de captura en JavaScript (w3.unpocodetodo.info)]]
    2. [[https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html][POSIX, Cuantificadores, Puntos de anclaje, Sustituciones, Escape de Caracteres (bioinf.comav.upv.es)]]
    3. [[https://www.linuxteck.com/sed-commands-in-linux/][sed commands in linux (linuxteck.com)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/63952656/using-awk-to-set-first-character-to-lowercase-unix][using awk to set first character to lowercase unix (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/2609552/how-can-i-use-as-an-awk-field-separator][how can I use as an awk field separator (stackoverflow.com)]]
    3. [[https://stackoverflow.com/questions/1251999/how-can-i-replace-each-newline-n-with-a-space-using-sed][how can I replace each newline n with a space using sed command (stackoverflow.com)]]
    4. [[https://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group-in-regular-expressions][what is a non capturing group in regular expressions (stackoverflow.com)]]
    5. [[https://superuser.com/questions/112834/how-to-match-whitespace-in-sed][how to match whitespace in sed command (superuser.com)]]
