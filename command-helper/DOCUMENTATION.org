#+TITLE: Documentation
* Intro
  #+BEGIN_QUOTE
  Centralizamos los comentarios sobre las implementaciones en los Makefiles,
  para separar la explicación de la implementación en si
  #+END_QUOTE
* Comparación de Timestamp entre Target y sus dependencias
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Problemas con éste target:
    #
    # 1. al utilizar el símbolo ; dentro del foreach se ejecutará en cada iteración
    # y al igual que en la terminal de linux, hará que cada comando se ejecute de forma independiente
    #
    # 2. lo anterior es problema suponiendo que queremos transformar la información generada
    # (Ej. agregandole una cabecera)
    #
    imprimir-comando-descripcion:
    $(foreach comando, $(DOC_COMANDOS_LINUX), cat $(comando) | sed -n '1p';)
  #+END_SRC

  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Problemas con estos targets:
    #
    # 1. estamos creando un archivo comandos-linux.txt cada vez que ejecutamos imprimir-comandos,
    # es decir no comprobamos si se actualizaron ó no los archivos contenidos en $(DOC_COMANDOS_LINUX)
    #
    # 2. no estamos aprovechando la comparación del timestamp entre el target y las dependencias para crear archivos de GNU Make,
    # la manera más común sería una regla como la siguiente.. archivo-transformado.txt: archivo1.txt archivo2.txt archivo3.txt
    #
    imprimir-comandos: comandos-linux.txt

    comandos-linux.txt:
      $(foreach comando, $(DOC_COMANDOS_LINUX), cat $(comando) | sed -n '1p';)
  #+END_SRC
* Función Basename
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)

    # Nota: $(patsubst pattern, replacement, text)

    # Problemas:
    # 1. NO era necesario utilizar la función patsubst, sólo necesitabamos usar la función basename de GNU Make
    # 2. Si bien le ponemos "WRONG", éste método funciona pero se pierde expresividad y es más dificil de mantener
    COMANDOS_LINUX_WRONG = $(notdir $(patsubst %.sh,%,$(DOC_COMANDOS_LINUX)))

    COMANDOS_LINUX = $(basename $(notdir $(DOC_COMANDOS_LINUX)))
  #+END_SRC
* Función filter-out
  #+BEGIN_SRC makefile
    DOC_COMANDOS_LINUX = $(wildcard doc/*.sh)
    DOC_SHORTCUTS_LINUX = $(wildcard doc/*.org)

    # Nota: $(filter-out pattern, text)
    #
    # 1. Filtramos de (A) los elementos (a) que no estén incluidos en otra lista (B)
    #
    COMANDOS_LINUX_WITHOUT_SHORTCUTS = $(filter-out $(SHORTCUTS_LINUX),$(COMANDOS_LINUX))
  #+END_SRC
* Comando bat
** Problema al ejecutar
  #+BEGIN_QUOTE
  *Posible Problema:*
  - al ejecutar el binario el emulador de terminal diga ~Command 'bat' not found~

  *Solución:*
  - crear un softlink de ~/usr/bin/batcat~ en  ~~/.local/bin/bat~
  #+END_QUOTE

#+BEGIN_SRC shell
  # suponiendo que no existe el directorio
  mkdir -p ~/.local/bin

  # creamos el softlink /usr/bin/batcat en ~/.local/bin/bat
  ln -s /usr/bin/batcat ~/.local/bin/bat
#+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://www.makeuseof.com/bat-an-alternative-to-cat-command/][bat an alternative to cat omcmand (makeuseof.com)]]
*** Referencias Issues
    1. [[https://github.com/sharkdp/bat/issues/1420#issuecomment-737058971][Bat doesn't work when installed from apt on ubuntu (github.com/sharkdp/bat)]]
* Macro Expansiva Vs Macro Simple - Evaluación y Expansión de Macro con comando shell
** Problemas
  #+BEGIN_QUOTE
  Según la que eligamos dará *problemas ó no cuando les asignamos un comando de shell*..

  Si es una *MACRO RECURSIVA*, entonces utilizamos el símbolo de asignación ~=~
  Por ejemplo ~archivo-especifico = $(shell ls *.md | grep '^READ')~
  - PROBLEMA 1: GNU Make lo evaluará y expandirá cada vez que se referencie en el Makefile
  - PROBLEMA 2: ejecuta el comando a cada rato, en lugares dónde aún no queríamos que se ejecutara (Ej. en un ifeq)

  Si es una *MACRO SIMPLE*, entonces utilizamos el símbolo de asignación ~:=~
  - Por ejemplo ~archivo-especifico := $(shell ls *.org | grep 'TODO\.org$')~
  - PROBLEMA 1: GNU Make lo evaluará varias veces pero se expandirá una única vez (la primera vez que se referenció)
  - PROBLEMA 2: ejecutará apenas ejecutamos el Makefile (peor que antes)
  #+END_QUOTE

  #+BEGIN_SRC makefile
    # a diferencia de las alternativas de abajo, ésta si funciona y evitamos los problemas de expansión no deseada de GNU Make
    POPUP_EDIT = sh ./scripts/edit-popup.sh

    # Notas:
    # - en todas las siguientes asignaciones causarán problemas cuando GNU Make las evalué y expanda
    # - de igual forma las comento por el tema de que cada linea en una regla de Makefile se ejecuta en una shell diferente

    # 1. alternativa a la función shell sería usando el símbolo !=
    # 2. en éste ejemplo considero que queda mejor usar shell para no confundir y no olvidar que el comando read es propio de linux
    POPUP_EDIT != read -p "Si desea editar comandos escriba sin paréntesis (c) y para shortcuts (s): " popup_edit; echo $$popup_edit

    #
    # 1. nuestro comando shell imprimirá un string que se asignará a la macro POPUP_EDIT
    # 2. los comandos de linux se ejecutarán en la misma shell, por tanto se perderá el valor si intentamos imprimir $$popup_edit en otra macro ó target
     POPUP_EDIT ?= $(shell read -p "Desea editar comandos escriba (c) para shortcuts (s): " popup_edit; echo $$popup_edit)

    # 1. también sólo podriamos asignar los comandos a ejecutar como un string
    # 2. para no perder el valor de popup_edit podríamos utilizar el operador && para manternos en la misma shell así $(POPUP_EDIT) && echo $$popup_edit
    # pero... no podriamos utilizarlo en un ifeq de GNU Make
     POPUP_EDIT = read -p "Si desea editar comandos escriba sin paréntesis (c) y para shortcuts (s): " popup_edit; echo $$popup_edit
  #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://make.mad-scientist.net/deferred-simple-variable-expansion/][Deferred simple variable expansion (make-mad-scientist.net)]]
    2. [[https://seanbone.ch/makefile-hacks/][Makefile hacks (seanbone.ch)]]
*** Referencias Issues
    1. [[https://nono.ma/prompt-user-input-makefile][Prompt user input makefile (nono.ma)]]
    2. [[https://stackoverflow.com/questions/3743793/makefile-why-is-the-read-command-not-reading-the-user-input][makefile why is the read command not reading the user input (stackoverflow.com)]]
    3. [[https://unix.stackexchange.com/questions/31414/how-can-i-pass-a-command-line-argument-into-a-shell-script][How can I pass a command line argument into a shell script (unix.stackexchange.com)]]
    4. [[https://stackoverflow.com/questions/32153034/oneshell-not-working-properly-in-makefile][Oneshell not working properly in makefile (stackoverflow.com)]]
* Condicionales Simples de Bash
** Problemas
  #+BEGIN_QUOTE
  Podemos usar el comando ~test -f archivo~ para verificar si existe con los operadores lógicos ~&&~ y ~||~
  - la expresión seguida del operador lógico AND ~&&~ se evalúa si existe el archivo
  - la expresión seguida del operador lógico OR ~||~ se evalúa si NO existe el archivo

  ó podemos usar el condicional ~if [ -s archivo ]~ sin olvidar el uso de los ~;~
  - usar ~;~ al final de cada expresión delimitada dentro de la condición ~if~ ó del ~else~
  - finalizar el bloque ~if~ con un ~fi~
  #+END_QUOTE

  #+BEGIN_SRC makefile
    doc/archivo.txt: .tmp/archivo-4.txt .tmp/archivo-1.txt .tmp/archivo-9.txt
      @test -f $@ \
      && echo "existe el archivo..!" \
      || echo "no existe el archivo, ejecutar algún comando que procese los archivos dependencia y cree el archivo"

    doc/otro-archivo.txt: .tmp/archivo-1.txt .tmp/archivo-2.txt .tmp/archivo-3.txt
      @if [ -s $@  ]; then \
        echo "existe el archivo"; \
      else \
        echo "no existe el archivo, ejecutar algún comando que procese los archivos dependencia y cree el archivo"; \
      fi
  #+END_SRC
** Referencias
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/5553352/how-do-i-check-if-file-exists-in-makefile-so-i-can-delete-it][How do I check if file exists in makefile (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/8059556/how-to-write-multiple-conditions-in-makefile-am-with-else-if][How to write multiple conditions in makefile (stackoverflow.com)]]
* Comandos awk + sed - Expresiones Regulares
** Ejemplo Básico
  #+BEGIN_QUOTE
  Generamos un archivo ~comandos-linux.txt~ en base al contenido de sus dependencias (los .sh)
  - siempre que en una regla de Makefile haya una diferencia en el *timestamp* entre el TARGET y sus DEPENDENCIAS
  - con la diferencia de timestamp, GNU Make nos permitirá ejecutar la orden asociada a la creación del TARGET
  - creamos el archivo (target) cuando los archivos de los que depende (sus dependencias) tienen una fecha de modificación más reciente
 #+END_QUOTE

  #+BEGIN_SRC makefile
    # - truncamos el archivo, lo modificamos el tamaño del archivo a cero Bytes
    # - todos los datos que tenía se pierden
    archivo.txt:
      @truncate -s 0 $@

    # - iteramos sobre cada dependencia del target
    # - la macro especial $^ obtiene todas  las dependencias
    # - la función foreach es de la forma (foreach elemento-de-la-lista, lista-de-archivos, orden-a-ejecutar)
    # - para utilizar el elemento de la iteración del foreach dentro de la orden que ejecuta, debemos hacerlo como una macro $(elemento-de-la-lista)
    @$(foreach comando, $^, echo $(comando))

    # obtenemos una linea en particular del archivo (la descripción, en la primera linea)
    cat archivo.txt | sed -n '1p'

    # agregamos un string al principio de cada linea
    cat archivo.txt | nawk '{print "$(basename $(notdir $(comando))) " $$0}'

    # - reemplazamos los símbolos no deseados por ejemplo ~#~ por otro por ej. el pipe ~|~
    # - escapamos los símbolos usando el slash invertido
    cat archivo.txt | sed 's/\#/\|/g'

    # - agregamos el texto transformado en el target (el archivo comandos-linux.txt)
    # - el operador de redirección ~>>~ que agrega contenido (si usaramos ~>~ borraría el contenido anterior)
    # - la macro especial ~$@~ que obtiene el nombre del target
    archivo.txt:
      echo "texto transformado" >> $@
  #+END_SRC

  #+BEGIN_SRC makefile
    comandos-linux.txt: doc/ls.sh doc/mv.sh doc/tar.sh doc/curl.sh
      @$(TRUNCATE_CLEAR_CONTENT) $@
      @$(foreach comando, $^,\
      cat $(comando) | sed -n '1p' | nawk '{print "$(basename $(notdir $(comando))) " $$0}' | sed 's/\#/\|/g' \
      >> $@;\
    )
  #+END_SRC
** Ejemplo
  #+BEGIN_SRC makefile
    comandos-linux.txt: doc/ls.sh doc/mv.sh doc/tar.sh doc/curl.sh
      @$(TRUNCATE_CLEAR_CONTENT) $@
      @$(foreach comando, $^,\
        cat $(comando) | \
        sed -n '1,2p' | \
        nawk 'BEGIN{print "$(basename $(notdir $(comando)))|" } {print $$0}' | \
        sed -E 's/\#\# (CATEGORIA)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2\|/g' | \
        sed -E 's/\#\# (DESCRIPCION)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2;/g' | \
        tr --delete '\n' | tr ';' '\n' | \
        nawk -F '|' '{print $$1 " | " toupper($$2) " | " toupper(substr($$3,1,1)) substr($$3,2)}' \
        >> $@;\
      )
  #+END_SRC

  #+BEGIN_SRC makefile
    # extraemos sólo las lineas 1 y 2 del archivo
    cat archivo.txt | sed -n '1,2p'

    # - agregamos al principio de cada linea un texto, en éste caso la macro comando
    # - la función notdir obtiene el nombre del archivo (con la extensión, usaremos basename para removerla)
    # - la función basename obtiene el nombre del archivo sin la extensión
    # - usamos $$0 en vez de $0 para que GNU Make no la tome como una macro de Makefile si que la escape é interprete un caracter y sea un parámetro del comando awk
    cat archivo.txt | nawk 'BEGIN{print "$(basename $(notdir $(comando)))|" } {print $$0}'

    # - en las regex es típico usar paréntesis para los Grupos de Captura (Capture Group) es decir son "Construcciones de Agrupamiento de Expresiones Regulares"
    # - en awk obtenemos el contenido de los Grupos de Captura con \1 \2 .. \n siendo n el número del grupo de captura del que queremos el contenido
    cat archivo.txt | sed -E 's/\#\# (CATEGORIA)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2\|/g'

    # - al final de cada columna de awk le agregamos un símbolo ; como centinela para detectar el fin de linea
    cat archivo.txt | sed -E 's/\#\# (DESCRIPCION)\: (([[:alnum:]]|[[:space:]]|[[:punct:]])+)$$/\2;/g'

    # borramos los saltos de linea
    cat archivo.txt | tr --delete '\n'

    # reemplazamos los ; por saltos de linea (antes los habíamos agregado para diferenciar el fin de linea)
    cat archivo.txt | tr ';' '\n'

    # - indicamos que el separador de las columnas en el símbolo | (el pipe)
    # - transformamos el texto manipulando el orden de las columnas $1 $2 $3 detectadas por awk
    # (recordando que agregamos un $ al principio $$1 $$2 .. porque si nó GNU Make lo tomará como una macro, y queremos que lo tome como un caracter)
    cat archivo.txt | nawk -F '|' '{print $$1 " | " toupper($$2) " | " toupper(substr($$3,1,1)) substr($$3,2)}'
  #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://learn.microsoft.com/es-es/dotnet/standard/base-types/grouping-constructs-in-regular-expressions][Construcciones de agrupamiento en expresiones regulares (learn.mirosoft.com)]]
*** Referencias Extraoficiales
    1. [[http://w3.unpocodetodo.info/utiles/regex-en-javascript.php][Grupos de captura en JavaScript (w3.unpocodetodo.info)]]
    2. [[https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html][POSIX, Cuantificadores, Puntos de anclaje, Sustituciones, Escape de Caracteres (bioinf.comav.upv.es)]]
    3. [[https://www.linuxteck.com/sed-commands-in-linux/][sed commands in linux (linuxteck.com)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/63952656/using-awk-to-set-first-character-to-lowercase-unix][using awk to set first character to lowercase unix (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/2609552/how-can-i-use-as-an-awk-field-separator][how can I use as an awk field separator (stackoverflow.com)]]
    3. [[https://stackoverflow.com/questions/1251999/how-can-i-replace-each-newline-n-with-a-space-using-sed][how can I replace each newline n with a space using sed command (stackoverflow.com)]]
    4. [[https://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group-in-regular-expressions][what is a non capturing group in regular expressions (stackoverflow.com)]]
    5. [[https://superuser.com/questions/112834/how-to-match-whitespace-in-sed][how to match whitespace in sed command (superuser.com)]]
* Comandos xargs y whiptail + Llamado recursivo a un Makefile
** Posibles Escenarios
*** Escenario (1) con GNU Make
    #+BEGIN_QUOTE
    1) Interactuamos con el usuario mediante un cuadro de diálogo
    2) Usaremos el programa ~whiptail~ para la interfáz del cuadro de diálogo
    3) Redireccionamos el stderr al stdout para capturar lo que escribe ~whiptail~
    4) Capturamos el valor de salida de ~whiptail~ con ~xargs~ para crear nuevos archivos a partir de otros (templates)
    #+END_QUOTE

    #+BEGIN_SRC makefile
      # alternativa al `rsync --ignore-existing` sería `cp --no-clobber`
      COPY_NOT_OVERWRITE=rsync --ignore-existing

      DOC_COMMANDS_LINUX_DIRECTORY=doc/linux-shell/commands
      DOC_SHORTCUTS_LINUX_DIRECTORY=doc/linux-shell/shortcuts

      MENU_CREATE_DOC_LINUX= whiptail \
        --inputbox "Escriba el nombre del comando" 25 80 \
        --title "Crear Documentación de Linux"

      linux-create-doc:
        $(MENU_CREATE_DOC_LINUX) 3>&1 1>&2 2>&3 \
        | xargs -I % sh -c "\
        $(COPY_NOT_OVERWRITE) $(DOC_COMMANDS_LINUX_DIRECTORY)/.template $(DOC_COMMANDS_LINUX_DIRECTORY)/%.sh; \
        $(COPY_NOT_OVERWRITE) $(DOC_SHORTCUTS_LINUX_DIRECTORY)/.template $(DOC_SHORTCUTS_LINUX_DIRECTORY)/%.org; \
        echo 'Se creó el archivo $(DOC_COMMANDS_LINUX_DIRECTORY)/%.sh;' \
        echo 'Se creó el archivo $(DOC_SHORTCUTS_LINUX_DIRECTORY)/%.org'; \
        "
    #+END_SRC
*** Escenario (2) con GNU Make - Makefile recursivo
    #+BEGIN_QUOTE
    1) Capturamos la opción elegida del menu de ~whiptail~ con ~xargs~
    2) La *opción capturada* será el nombre del ~target~ que pasaremos por parámetro al mismo ~Makefile~ para ejecutar
    3) Con ~$(MAKE)~ se invoca a si mismo el Makefile
    #+END_QUOTE

    #+BEGIN_SRC makefile
      # Notas:
      # 1. es necesario definir los targets linux-create-doc y app-create-doc
      # 2. al confirmarle a whiptail una opción, la enviará al stdout (file descriptor 1, la pantalla)
      # y GNU Make interpretará que el resultado es el nombre de un target
      # (si no existen esos targets GNU Make lanzará un error de que deben definirse en el Makefile)
      MENU_CREATE_DOC=whiptail \
        --title "Crear documentación" \
        --menu "Elegir una opción" 30 80 5 \
        "linux-create-doc" "Documentación de Linux" \
        "app-create-doc" "Documentación de una Aplicación"

      create-doc:
        $(MENU_CREATE_DOC) 3>&1 1>&2 2>&3 \
        | xargs -I % $(MAKE) --no-print-directory %
    #+END_SRC
*** Escenario Alternativo - Usando comando read
   #+BEGIN_SRC makefile
     linux-create-doc:
       read -p "Nombre del Comando de Linux a documentar: " NOMBRE \
       && echo $(DOC_COMMANDS_LINUX_DIRECTORY)/$$NOMBRE.$(DOC_COMMANDS_EXTENSION) \
       && echo $(DOC_SHORTCUTS_LINUX_DIRECTORY)/$$NOMBRE.$(DOC_SHORTCUTS_EXTENSION)

     # otra alternativa
     linux-create-doc:
       printf "Nombre del Comando de Linux a documentar: " && read NOMBRE \
       && echo $(DOC_COMMANDS_LINUX_DIRECTORY)/$$NOMBRE.$(DOC_COMMANDS_EXTENSION) \
       && echo $(DOC_SHORTCUTS_LINUX_DIRECTORY)/$$NOMBRE.$(DOC_SHORTCUTS_EXTENSION)
   #+END_SRC
** Comando xargs - Mismo parámetro a múltiples comandos
   #+BEGIN_QUOTE
   El comando ~xargs~ requiere utilizarlo la forma ~xargs -I % sh -c 'comando1 %; comando2 %; ..'~
   cuando queremos pasar el mismo parámetro ~%~ a multiples comandos en la misma Shell

   El símbolo ~%~ que usamos en los nombres de los ficheros, es el parámetro capturado por el comando ~xargs~ con la opción ~-I~
   #+END_QUOTE
** Comando whiptail - Redirección entre File Descriptors
*** Problema
    - el comando ~whiptail~ por defecto escribe sobre el ~stderr~ (fd 2)
    - necesitamos redireccionar el ~stderr~ (fd 2) al ~stdout~ (fd 1)
*** Solución 1 - Utilizar la terminal activa /dev/tty
    - utilizar el operador de redirección ~>~ de la forma ~file descriptor>&otro fd~
    - redireccionar STDERR a STDOUT y luego STDOUT a la terminal activa (la que está en uso)

    #+BEGIN_QUOTE
    Planteandolo quedaría ~2>&1 > /dev/tty~
    1) ~2>&1~ redireccionamos el STDERR (file descriptor 2) a STDOUT (file descriptor 1)
    2) ~> /dev/tty~ redireccionamos el STDOUT a la terminal activa (la que está en uso)
    #+END_QUOTE
*** Solución 2 - Crear nuevo file descriptor
    - utilizar el operador de redirección ~>~ de la forma ~file descriptor>&otro fd~
    - crear un *File Descriptor* adicional que guarde la referencia del stdout

    #+BEGIN_QUOTE
    Planteandolo quedaría ~3>&1 1>&2 2>&3~
    1) ~3>&1~ creamos un nuevo File Descriptor (fd 3) que guarda la referencia del stdout (fd 1)
    2) ~1>&2~ redireccionamos el stdout->stderr
    3) ~2>&3~ redireccionamos el stderr->nuevo file descriptor (fd 3, el que apuntaba al stdout)
    #+END_QUOTE
** Referencias
*** Referencias Extraoficiales
    1) [[https://phoenixnap.com/kb/xargs-command][xargs Command examples (phoenixnap.com)]]
* Comandos read y whiptail - Redirección de la Terminal activa /dev/tty
** Formas de Redirección utilizadas
*** Operador Pipe (|)
    - *redirecciona el STDOUT* como STDIN de otro comando
    - ejemplo ~ls *.txt | grep ^b~ (listar todos los archivos de texto plano que empiecen con la letra b)
*** Operador (<)
    - *redirecciona el contenido de un archivo* como STDIN de un comando
    - ejemplo ~tr 'a-z' 'A-Z' < alumnos.txt~ (convertimos todos caracteres en mayúsculas)

    #+BEGIN_QUOTE
    En el posible escenario (1) planteado, que combinamos los comandos ~whiptail~ y ~read~
    - Redireccionamos el *contenido de la terminal en uso* (activa) ~/dev/tty~ con el operador de redirección ~<~
    - ES FUNDAMENTAL la redirección ~< /dev/tty~ caso contrario.. el comando ~read~ FALLARÁ..
    #+END_QUOTE
** Posibles Escenarios
*** Escenario (1) con GNU Make - Comando read
    #+BEGIN_QUOTE
    Primero la interacción con ~whiptail~ (no es el tema de interés al menos en éste escenario)
    1) Utilizamos ~whiptail~ para mostrar una caja de dialogo
    2) Redireccionamos los *File Descriptor* (STDERR -> STDOUT) para
       - porque por default escriben en el *STDERR* (fd 2)
       - utilizar la salida de ~whiptail~ como entrada de otro comando con el operador pipe ~|~
       - pasar por parámetro el resultado de ~whiptail~ al propio ~Makefile~ con el comando ~xargs~
       - el parámetro recibido por el ~Makefile~, lo interpeta *GNU Make* como el nombre de un target (que debe estar definido en el Makefile)
    3) Elegida una opción de ~whiptail~, la llamada recursiva ~$(MAKE)~ recibe el nombre del target pasado por parámetro por ~xargs~
    #+END_QUOTE

    #+BEGIN_QUOTE
    Segundo la interacción con el comando ~read~ y el operador de redireccion ~<~ (éste era el tema de interés)
    1) Solicitamos por *STDIN* (fd 0) que ingrese el nombre del comando ó aplicación con el comando ~read~
    2) Redireccionamos el *contenido de la terminal en uso* (activa) ~/dev/tty~ con el operador de redirección ~<~
    #+END_QUOTE

    #+BEGIN_SRC makefile
      MENU_CREATE_DOC=whiptail \
      --title "Crear documentación" \
      --menu "Elegir una opción" 30 80 5 \
      "linux-create-doc" "Documentación de Linux" \
      "app-create-doc" "Documentación de una Aplicación"

      # No es necesario utilizar la opción -I, la utilizamos para asignarle un símbolo al parámetro que recibe xargs (el %)
      # y que se entienda que se lo estamos pasando por parámetro al llamado recursivo $(MAKE)
      create-doc:
        $(MENU_CREATE_DOC) 2>&1 > /dev/tty \
        | xargs $(MAKE) --no-print-directory

      # alternativa al 2>&1 >/dev/tty
      # create-doc:
      #  $(MENU_CREATE_DOC) 3>&1 1>&2 2>&3 \
      #  | xargs -I % $(MAKE) --no-print-directory %

      # Notas:
      # 1. Una alternativa a ~read -p "texto" VARIABLE~ sería ~echo "texto: " && read VARIABLE~
      linux-create-doc:
      read -p "Nombre del Comando de Linux a documentar: " NOMBRE < /dev/tty \
      && $(TEXT_EDITOR) $$NOMBRE.sh

      app-create-doc:
      read -p "Nombre de la Aplicación a documentar: " NOMBRE < /dev/tty \
      && $(TEXT_EDITOR) $$NOMBRE.org

      .PHONY: create-doc linux-create-doc app-create-doc
    #+END_SRC
*** Escenario (2) con GNU Make - Comando whiptail con cuadro de dialogo
    #+BEGIN_SRC makefile
      LINUX_COMMANDS_LIST=ls ps find tee
      LINUX_SHORTCUTS_LIST=neovim screen

      MENU_EDIT_LINUX_COMMANDS=whiptail \
        --title "Editar documentación de Linux" \
        --menu "Elegir una opción" 0 0 5 $(LINUX_COMMANDS_LIST)

      MENU_EDIT_LINUX_SHORTCUTS=whiptail \
        --title "Editar documentación de Linux" \
        --menu "Elegir una opción" 0 0 5 $(LINUX_SHORTCUTS_LIST)

      linux-edit-commands: linux-shell.txt
        $(MENU_EDIT_LINUX_COMMANDS) 3>&1 1>&2 2>&3 \
        | xargs -I % $(TEXT_EDITOR) $(DOC_COMMANDS_LINUX_DIRECTORY)/%.$(DOC_COMMANDS_EXTENSION)

      linux-edit-shortcuts:
        $(MENU_EDIT_LINUX_SHORTCUTS) 3>&1 1>&2 2>&3 \
        | xargs -I % $(TEXT_EDITOR) $(DOC_COMMANDS_LINUX_DIRECTORY)/%.$(DOC_COMMANDS_EXTENSION)
    #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://www.baeldung.com/linux/monitor-keyboard-drivers][Difference between /dev/tty and /dev/tty0 (baeldung.com)]]
    2. [[https://linuxhandbook.com/redirection-linux/][Explained: input, output and error redirection in linux (linuxhandbook.com)]]
    3. [[https://linuxhandbook.com/read-command/][Practical examples of the read command in Linux (linuxhandbook.com)]]
*** Referencias Issues
    1. [[https://unix.stackexchange.com/questions/229530/how-linux-uses-dev-tty-and-dev-tty0][How linux uses dev/tty and dev/tty0 (unix.stackexchange.com)]]
    2. [[Https://stackoverflow.com/questions/39631144/why-command-read-doesnt-work][Why command read doesn't work (stackoverflow.com)]]
    3. [[https://stackoverflow.com/questions/6674327/redirect-all-output-to-file-in-bash/6674383#6674383][Redirect all output to file in bash (stackoverflow.com)]]
    4. [[https://stackoverflow.com/questions/1562666/bash-scripts-whiptail-file-select][Bash scripts whiptail file select (stackoverflow.com)]]
* GNU Make - Pasar parámetros sin valor asociado con MAKECMDGOALS y filter
** Problema
   #+BEGIN_QUOTE
   1) Queremos pasar un parámetro a un target sin asignarle un valor
   2) Ejecutar en la terminal de comandos ~make mkdir editar~ en vez de ~make editar-comando=mkdir~
   #+END_QUOTE
** Solución
  #+BEGIN_SRC makefile
    DOC_COMMANDS_LINUX_DIRECTORY=doc/linux-shell/commands
    TEXT_EDITOR=vim

    # necesario para poder usar la palabra `edit` como parámetro de cualquier target
    $(eval edit:;@:)

    $(COMANDOS_LINUX):
    # 1. validamos si pasó el parámetro "edit" en la terminal de comandos, al ejecutar make instanciando un target incluido la macro $(COMANDOS_LINUX)
    ifeq (edit, $(filter edit,$(MAKECMDGOALS)))
    # 1.1 abrimos el archivo en modo de edición con algún programa (Ej. vim, nano, ..)
      $(TEXT_EDITOR) $(DOC_COMMANDS_LINUX_DIRECTORY)/$@.sh
    # 1.2 flujo alternativo, si no pasó el parámetro "edit",
    # entonces sólo imprimimos el contenido del archivo
    else
      cat $(DOC_COMMANDS_LINUX_DIRECTORY)/$@.sh
    endif

      @test -f $(DOC_COMMANDS_LINUX_DIRECTORY)/$@.sh \
        && cat $(TEXT_EDITOR) $(DOC_COMMANDS_LINUX_DIRECTORY)/$@.sh
        || true
  #+END_SRC
** Comandos utilizados
*** Comando test
  - lo usamos ara *validar existencia de archivos*
  - utilizado de la forma ~test -f archivo.txt && echo "existe" || echo "no existe"~
* GNU Make - Macro con comandos de Shell y utilizada como parámetro a otra función Shell
** Problema
   #+BEGIN_QUOTE
   1) Transformar el texto de un target (en este ej. es ~SHORTCUTS_LINUX~)
   2) Agregar saltos de linea (el caracter especial ~\n~) con el comando de linux ~sed~, porque las *funciones de sustitución de GNU Make* no lo hacen
   3) *Pasar por parámetro la macro* con el texto transformado con ~sed~ al comando linux ~awk~ para *filtrar contenido de un archivo* de texto plano
   #+END_QUOTE
** Sugerencias
  #+BEGIN_QUOTE
  Si usamos una ~Macro (A)~ que transforma e imprime el texto de otra ~Macro (B)~,
  y esa la ~Macro (A)~ la utilizamos como un comando dentro de una regla para crear un Target/Objetivo,
  entonces *GNU Make* buscará en el Makefile los targets con esos nombres..

  Si ese no era nuestra meta y no habíamos definido targets con esos nombres,
  entonces *GNU Make* FALLARÁ diciendo que *NO encontró los targets* para crear el target principal (dónde se incluyó la macro)

  En este ejemplo utilizamos la ~Macro (A)~ como parámetro de un comando de linux
  #+END_QUOTE
** Solución
  #+BEGIN_SRC makefile
    DOC_COMMANDS_LINUX_DIRECTORY=doc/linux-shell/commands
    DOC_SHORTCUTS_LINUX = $(wildcard $(DOC_SHORTCUTS_LINUX_DIRECTORY)/*.org)
    SHORTCUTS_LINUX = $(basename $(notdir $(DOC_SHORTCUTS_LINUX)))

    # Notas:
    # 1. formateamos la lista de palabras, reemplazando los espacios por el pipe | como separador
    # 2. permite controlar el contenido del archivo con el comando de linux AWK
    SHORTCUTS_LINUX_FORMAT=$(shell echo $(SHORTCUTS_LINUX) | sed -E 's/([[:alpha:]]+) /\1|/g')

    # Notas:
    # 1. si usamos el operador != en vez de la función $(shell ) no cumplía su propósito el slash invertido
    # 2. en véz de borrar lineas con el comando sed y su opción /d, se prefirió filtrar filas con awk que también permite patrones (más fácil)
    LINUX_SHORTCUTS_LIST=$(shell cat commands-linux-shell.txt \
      | awk -F '|' '{print $$1 "::" $$2}' \
      | sed -E 's/([[:alpha:]]+)::(.+)/\"\1\" \"\2\"\\/g' \
      | awk '/$(SHORTCUTS_LINUX_FORMAT)/' \
      | tr '\\' '\n')
  #+END_SRC
** Soluciones fallidas
   #+BEGIN_SRC makefile
     # el comando `tr` no cumplía su propósito a diferencia del comando `sed`
     SHORTCUTS_LINUX_FORMAT_FAIL = $(shell echo $(SHORTCUTS_LINUX) | tr '[:space:]' '\|')

     # el operador de redirección <<< falla
     SHORTCUTS_LINUX_FORMAT_FAIL = sed -E 's/([[:alpha:]]+) /\1|/g' <<< "$(SHORTCUTS_LINUX)"

     # ésta fue la macro utilizada, que no arroja errores
     SHORTCUTS_LINUX_FORMAT=$(shell echo $(SHORTCUTS_LINUX) | sed -E 's/([[:alpha:]]+) /\1|/g')
   #+END_SRC
* GNU Make - Macro con comandos de Shell (awk + sed + tr)
** Objetivo
   - Adaptar el texto de un archivo que está de la forma ~dato1|dato2|~ a algo como ~"dato1" "dato2"~ seguidos de un salto de linea ~\n~
   - Crear un menú con el comando ~whiptail --menu~ con el texto transformado
** Problema
   1) Leer el contenido de un archivo de texto plano (.txt) que tiene columnas delimitadas por el símbolo pipe ~|~
   2) Cambiar el separador de columnas ~|~ por otro ~::~ con ~awk~ para facilitar la sustitución con ~sed~
   3) Sustituir los textos de las columnas separadas por ~::~ de la forma ~"palabra" "otra"~ seguido de un slash invertido ~\~
   4) Agregar saltos de linea al final de cada columna
** Solución
  #+BEGIN_QUOTE
  - si utilizamos ~!/patron/~ en ~awk~, filtramos el contenido de un archivo, usando el ~!~ como una negación ~NOT~
  - la solución actual con ~sed~ se complicaba el borrar lineas con varios patrones)
  #+END_QUOTE

  #+BEGIN_SRC makefile
    # faltan algunas macros, NO se agregaron enfocar ésta solución
    DOC_LINUX=linux-shell

    LINUX_COMMANDS_LIST=$(shell cat $(DOC_LINUX).txt \
      | nawk -F '|' '{print $$1 "::" $$2}' \
      | sed -E 's/(.+)::(.+)/"\1" "\2" \\/g' \
      | tr '\\' '\n')

    # Nota: Si usamos el operador != en vez de la función $(shell ) no cumplirá su propósito el slash invertido
    LINUX_SHORTCUTS_LIST=$(shell cat $(DOC_LINUX).txt \
      | awk -F '|' '{print $$1 "::" $$2}' \
      | sed -E 's/([[:alpha:]]+)::(.+)/\"\1\" \"\2\"\\/g' \
      | awk '/$(SHORTCUTS_LINUX_FORMAT)/' \
      | tr '\\' '\n')
  #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://www.baeldung.com/linux/delete-lines-containing-string-from-file][Delete lines containing string from file (baeldung.com)]]
    2. [[https://phoenixnap.com/kb/awk-command-in-linux][awk command in linux (phoenixnap.com)]]
*** Referencias Issues
    1. [[https://unix.stackexchange.com/questions/318839/awk-negative-regular-expression][awk negative regular expression (unix.stackexchange.com)]]
